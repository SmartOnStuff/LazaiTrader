Repository Structure

cloudflare/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ migration_registration_sessions.sql
â”‚   â”‚   â”œâ”€â”€ schema.sql
â”‚   â”‚   â”œâ”€â”€ sqlreference.txt
â”‚   â”œâ”€â”€ lt_tg/
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ worker.js
â”‚   â”‚   â”œâ”€â”€ wrangler.toml
â”‚   â”œâ”€â”€ lt_tg_deposit/
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ worker.js
â”‚   â”‚   â”œâ”€â”€ wrangler.toml
â”‚   â”œâ”€â”€ lt_tg_start/
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ worker.js
â”‚   â”‚   â”œâ”€â”€ wrangler.toml


File Contents

// filepath: database\README.md
# LazaiTrader D1 Database

This folder contains the Cloudflare D1 database schema and configuration for the LazaiTrader bot.

## Database Overview

**Database Type:** Cloudflare D1 (SQLite-based)

**Tables:** 10
- Chains
- Users
- Tokens
- TradingPairs
- UserTradingConfigs
- PriceHistory
- Trades
- TradeMetrics
- UserBalances
- Suggestions

**Views:** 5
- vw_ActiveUserTradingConfigs
- vw_TradeSummaryByUserPair
- vw_LatestPricesByPair
- vw_UserBalances
- vw_TradeDetails

## Setup Instructions

### 1. Create D1 Database

```bash
wrangler d1 create lazaitrader-db
```

This will output something like:
```
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader-db"
database_id = "xxxx-xxxx-xxxx-xxxx"
```

### 2. Update wrangler.toml

Add the D1 binding to your `cloudflare/lt_tg/wrangler.toml`:

```toml
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader-db"
database_id = "your-database-id-here"
```

### 3. Initialize Schema

Run the schema to create tables and seed initial data:

```bash
wrangler d1 execute lazaitrader-db --file=cloudflare/database/schema.sql
```

### 4. Verify Setup

Check if tables were created:

```bash
wrangler d1 execute lazaitrader-db --command="SELECT name FROM sqlite_master WHERE type='table'"
```

## Database Schema Details

### Core Tables

#### Users
Stores Telegram user information and wallet addresses.
- `UserID` - Telegram user ID (Primary Key)
- `UserWallet` - User's EOA wallet address
- `SCWAddress` - Smart Contract Wallet address
- `TelegramChatID` - Telegram chat ID
- `Username` - Telegram username

#### Chains
Blockchain network information.
- Pre-populated with:
  - Metis Andromeda (1088)
  - Hyperion Testnet (133717)
  - Zircuit (48900)

#### Tokens
Token details per chain.
- Pre-populated with testnet tokens:
  - tgMetis
  - tgUSDC
  - tgETH

#### TradingPairs
Available trading pairs per chain.
- Links BaseToken and QuoteToken
- Contains DEX and price source information

#### UserTradingConfigs
User-specific trading strategies.
- Trade percentage
- Trigger percentage
- Max/Min amounts
- Multiplier

### Transaction Tables

#### PriceHistory
Historical price data for trading pairs.

#### Trades
Individual trade records with transaction hashes.

#### TradeMetrics
Additional metrics per trade (consecutive counts, etc.).

#### UserBalances
Current token balances per user.

#### Suggestions
AI-generated trading suggestions for users.

## Usage in Worker

### Accessing the Database

In your worker code, access D1 via the binding:

```javascript
export default {
  async fetch(request, env) {
    // env.DB is your D1 database
    const result = await env.DB.prepare(
      "SELECT * FROM Users WHERE TelegramChatID = ?"
    ).bind(chatId).first();

    return new Response(JSON.stringify(result));
  }
};
```

### Common Queries

#### Get User by Telegram Chat ID
```javascript
const user = await env.DB.prepare(
  "SELECT * FROM Users WHERE TelegramChatID = ?"
).bind(chatId).first();
```

#### Insert New User
```javascript
await env.DB.prepare(
  `INSERT INTO Users (UserID, UserWallet, SCWAddress, TelegramChatID, Username, RegisteredAt)
   VALUES (?, ?, ?, ?, ?, datetime('now'))`
).bind(userId, userWallet, scwAddress, chatId, username).run();
```

#### Get Active Trading Configs
```javascript
const configs = await env.DB.prepare(
  "SELECT * FROM vw_ActiveUserTradingConfigs WHERE UserID = ?"
).bind(userId).all();
```

#### Get Available Trading Pairs
```javascript
const pairs = await env.DB.prepare(
  `SELECT tp.*, bt.Symbol as BaseToken, qt.Symbol as QuoteToken
   FROM TradingPairs tp
   JOIN Tokens bt ON tp.BaseTokenID = bt.TokenID
   JOIN Tokens qt ON tp.QuoteTokenID = qt.TokenID
   WHERE tp.IsActive = 1 AND tp.ChainID = ?`
).bind(chainId).all();
```

## Local Development

### Test Queries Locally

```bash
wrangler d1 execute lazaitrader-db --command="SELECT * FROM Users"
```

### Import Data

```bash
wrangler d1 execute lazaitrader-db --file=data.sql
```

### Backup Database

```bash
wrangler d1 export lazaitrader-db --output=backup.sql
```

## Best Practices

1. **Use Prepared Statements**: Always use `.prepare()` with `.bind()` to prevent SQL injection
2. **Index Usage**: The schema includes optimized indexes for common queries
3. **Batch Operations**: Use D1 batch API for multiple inserts/updates
4. **Error Handling**: Always wrap D1 calls in try-catch blocks
5. **Constraints**: The schema enforces data integrity via foreign keys and checks

## Migration Strategy

For schema changes:

1. Create a new migration file: `migration_001.sql`
2. Test locally with `wrangler d1 execute`
3. Apply to production database
4. Update `schema.sql` to reflect current state

## Resources

- [Cloudflare D1 Docs](https://developers.cloudflare.com/d1/)
- [D1 Client API](https://developers.cloudflare.com/d1/platform/client-api/)
- [Wrangler D1 Commands](https://developers.cloudflare.com/workers/wrangler/commands/#d1)

// filepath: database\migration_registration_sessions.sql
-- Migration: Add RegistrationSessions table for tracking user registration state
-- This table is used by lt_tg_start worker to manage the registration flow

CREATE TABLE IF NOT EXISTS RegistrationSessions (
    SessionID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER NOT NULL UNIQUE,
    TelegramChatID TEXT NOT NULL,
    Username TEXT,
    State TEXT NOT NULL,  -- 'awaiting_wallet', etc.
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now'))
);

-- Index for faster lookups
CREATE INDEX IF NOT EXISTS IX_RegistrationSessions_UserID ON RegistrationSessions(UserID);
CREATE INDEX IF NOT EXISTS IX_RegistrationSessions_State ON RegistrationSessions(State);
CREATE INDEX IF NOT EXISTS IX_RegistrationSessions_CreatedAt ON RegistrationSessions(CreatedAt);

-- Add comment
-- This table stores temporary session data during user registration
-- Sessions are deleted once registration is complete

// filepath: database\schema.sql
-- =============================================
-- LazaiTrader Database Schema - Complete Reference
-- =============================================

-- TABLE 1: CHAINS
CREATE TABLE IF NOT EXISTS Chains (
    ChainID INTEGER PRIMARY KEY,
    ChainName TEXT NOT NULL UNIQUE,
    RPCEndpoint TEXT NOT NULL,
    ExplorerURL TEXT NOT NULL,
    NativeCurrency TEXT NOT NULL,
    IsActive INTEGER DEFAULT 1,
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now'))
);

-- TABLE 2: USERS
CREATE TABLE IF NOT EXISTS Users (
    UserID INTEGER PRIMARY KEY,
    UserWallet TEXT NOT NULL UNIQUE,
    SCWAddress TEXT,
    TelegramChatID TEXT NOT NULL UNIQUE,
    Username TEXT,
    RegisteredAt TEXT NOT NULL,
    IsActive INTEGER DEFAULT 1,
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now'))
);

-- TABLE 3: TOKENS
CREATE TABLE IF NOT EXISTS Tokens (
    TokenID INTEGER PRIMARY KEY AUTOINCREMENT,
    ChainID INTEGER NOT NULL,
    Symbol TEXT NOT NULL,
    TokenAddress TEXT NOT NULL,
    Decimals INTEGER NOT NULL,
    IsActive INTEGER DEFAULT 1,
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (ChainID) REFERENCES Chains(ChainID),
    UNIQUE(Symbol, ChainID),
    UNIQUE(TokenAddress, ChainID),
    CHECK (Decimals >= 0 AND Decimals <= 18)
);

-- TABLE 4: TRADING PAIRS
CREATE TABLE IF NOT EXISTS TradingPairs (
    PairID INTEGER PRIMARY KEY AUTOINCREMENT,
    ChainID INTEGER NOT NULL,
    PairName TEXT NOT NULL,
    BaseTokenID INTEGER NOT NULL,
    QuoteTokenID INTEGER NOT NULL,
    DEXAddress TEXT NOT NULL,
    PriceSource TEXT,
    PriceAPI TEXT,
    IsActive INTEGER DEFAULT 1,
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (ChainID) REFERENCES Chains(ChainID),
    FOREIGN KEY (BaseTokenID) REFERENCES Tokens(TokenID),
    FOREIGN KEY (QuoteTokenID) REFERENCES Tokens(TokenID),
    UNIQUE(PairName, ChainID),
    CHECK (BaseTokenID != QuoteTokenID)
);

-- TABLE 5: USER TRADING CONFIGS
CREATE TABLE IF NOT EXISTS UserTradingConfigs (
    ConfigID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER NOT NULL,
    PairID INTEGER NOT NULL,
    TradePercentage REAL NOT NULL,
    TriggerPercentage REAL NOT NULL,
    MaxAmount REAL NOT NULL,
    MinimumAmount REAL NOT NULL,
    Multiplier REAL NOT NULL,
    IsActive INTEGER DEFAULT 1,
    CreatedAt TEXT DEFAULT (datetime('now')),
    UpdatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (UserID) REFERENCES Users(UserID),
    FOREIGN KEY (PairID) REFERENCES TradingPairs(PairID),
    UNIQUE(UserID, PairID),
    CHECK (TradePercentage >= 0 AND TradePercentage <= 1),
    CHECK (TriggerPercentage >= 0 AND TriggerPercentage <= 1),
    CHECK (MaxAmount >= MinimumAmount)
);

-- TABLE 6: PRICE HISTORY
CREATE TABLE IF NOT EXISTS PriceHistory (
    PriceID INTEGER PRIMARY KEY AUTOINCREMENT,
    PairID INTEGER NOT NULL,
    Price REAL NOT NULL,
    CreatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (PairID) REFERENCES TradingPairs(PairID)
);

-- TABLE 7: TRADES
CREATE TABLE IF NOT EXISTS Trades (
    TradeID INTEGER PRIMARY KEY AUTOINCREMENT,
    PairID INTEGER NOT NULL,
    UserID INTEGER NOT NULL,
    PriceID INTEGER NOT NULL,
    Action TEXT NOT NULL,
    QuantitySent REAL NOT NULL,
    QuantityReceived REAL NOT NULL,
    TxHash TEXT NOT NULL UNIQUE,
    CreatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (PairID) REFERENCES TradingPairs(PairID),
    FOREIGN KEY (UserID) REFERENCES Users(UserID),
    FOREIGN KEY (PriceID) REFERENCES PriceHistory(PriceID),
    CHECK (Action IN ('BUY', 'SELL'))
);

-- TABLE 8: TRADE METRICS
CREATE TABLE IF NOT EXISTS TradeMetrics (
    MetricID INTEGER PRIMARY KEY AUTOINCREMENT,
    TradeID INTEGER NOT NULL,
    ConsecutiveCount INTEGER NOT NULL,
    ActualTradePercentage REAL NOT NULL,
    CreatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (TradeID) REFERENCES Trades(TradeID),
    UNIQUE(TradeID)
);

-- TABLE 9: USER BALANCES
CREATE TABLE IF NOT EXISTS UserBalances (
    BalanceID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER NOT NULL,
    TokenID INTEGER NOT NULL,
    Balance REAL NOT NULL,
    CreatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (UserID) REFERENCES Users(UserID),
    FOREIGN KEY (TokenID) REFERENCES Tokens(TokenID),
    UNIQUE(UserID, TokenID)
);

-- TABLE 10: SUGGESTIONS
CREATE TABLE IF NOT EXISTS Suggestions (
    SuggestionID INTEGER PRIMARY KEY AUTOINCREMENT,
    UserID INTEGER NOT NULL,
    Suggestion TEXT NOT NULL,
    InputData TEXT,
    CreatedAt TEXT DEFAULT (datetime('now')),
    FOREIGN KEY (UserID) REFERENCES Users(UserID)
);

-- =============================================
-- INDEXES
-- =============================================

-- Chains Indexes
CREATE INDEX IF NOT EXISTS IX_Chains_ChainName ON Chains(ChainName);
CREATE INDEX IF NOT EXISTS IX_Chains_IsActive ON Chains(IsActive);

-- Users Indexes
CREATE INDEX IF NOT EXISTS IX_Users_Username ON Users(Username);
CREATE INDEX IF NOT EXISTS IX_Users_SCWAddress ON Users(SCWAddress);

-- Tokens Indexes
CREATE INDEX IF NOT EXISTS IX_Tokens_Symbol ON Tokens(Symbol);
CREATE INDEX IF NOT EXISTS IX_Tokens_ChainID ON Tokens(ChainID);

-- Trading Pairs Indexes
CREATE INDEX IF NOT EXISTS IX_TradingPairs_ChainID ON TradingPairs(ChainID);
CREATE INDEX IF NOT EXISTS IX_TradingPairs_BaseToken ON TradingPairs(BaseTokenID);
CREATE INDEX IF NOT EXISTS IX_TradingPairs_QuoteToken ON TradingPairs(QuoteTokenID);

-- User Trading Configs Indexes
CREATE INDEX IF NOT EXISTS IX_UserTradingConfigs_User ON UserTradingConfigs(UserID);
CREATE INDEX IF NOT EXISTS IX_UserTradingConfigs_Pair ON UserTradingConfigs(PairID);

-- Price History Indexes
CREATE INDEX IF NOT EXISTS IX_PriceHistory_Pair_CreatedAt ON PriceHistory(PairID, CreatedAt DESC);
CREATE INDEX IF NOT EXISTS IX_PriceHistory_CreatedAt ON PriceHistory(CreatedAt);

-- Trades Indexes
CREATE INDEX IF NOT EXISTS IX_Trades_Pair_CreatedAt ON Trades(PairID, CreatedAt DESC);
CREATE INDEX IF NOT EXISTS IX_Trades_User ON Trades(UserID);
CREATE INDEX IF NOT EXISTS IX_Trades_CreatedAt ON Trades(CreatedAt);
CREATE INDEX IF NOT EXISTS IX_Trades_TxHash ON Trades(TxHash);
CREATE INDEX IF NOT EXISTS IX_Trades_User_CreatedAt ON Trades(UserID, CreatedAt DESC);

-- Trade Metrics Indexes
CREATE INDEX IF NOT EXISTS IX_TradeMetrics_TradeID ON TradeMetrics(TradeID);
CREATE INDEX IF NOT EXISTS IX_TradeMetrics_ConsecutiveCount ON TradeMetrics(ConsecutiveCount);

-- User Balances Indexes
CREATE INDEX IF NOT EXISTS IX_UserBalances_User ON UserBalances(UserID);
CREATE INDEX IF NOT EXISTS IX_UserBalances_Token ON UserBalances(TokenID);
CREATE INDEX IF NOT EXISTS IX_UserBalances_User_Token ON UserBalances(UserID, TokenID);
CREATE INDEX IF NOT EXISTS IX_UserBalances_Balance ON UserBalances(Balance);

-- Suggestions Indexes
CREATE INDEX IF NOT EXISTS IX_Suggestions_UserID ON Suggestions(UserID);
CREATE INDEX IF NOT EXISTS IX_Suggestions_CreatedAt ON Suggestions(CreatedAt DESC);

-- =============================================
-- COMMON DATA (Chains & Tokens Only)
-- =============================================

-- Insert Chains
INSERT INTO Chains (ChainID, ChainName, RPCEndpoint, ExplorerURL, NativeCurrency)
VALUES
(1088, 'Metis Andromeda', 'https://andromeda.metis.io/?owner=1088', 'https://explorer.metis.io', 'METIS'),
(133717, 'Hyperion Testnet', 'https://hyperion-testnet.metisdevops.link', 'https://hyperion-testnet-explorer.metisdevops.link', 'tMETIS'),
(48900, 'Zircuit', 'https://mainnet.zircuit.com', 'https://explorer.zircuit.com', 'ETH');

-- Insert Tokens (Hyperion Testnet)
INSERT INTO Tokens (ChainID, Symbol, TokenAddress, Decimals)
VALUES
(133717, 'tgMetis', '0x69Dd3C70Ae76256De7Ec9AF5893DEE49356D45fc', 18),
(133717, 'tgUSDC', '0x6Eb66c8bBD57FdA71ecCAAc40a56610C2CA8FDb8', 18),
(133717, 'tgETH', '0x2222Fe85Dbe1Bd7CCB44f367767862fDbe15d6a8', 18);

-- =============================================
-- VIEWS
-- =============================================

-- View: Active User Trading Configs
CREATE VIEW IF NOT EXISTS vw_ActiveUserTradingConfigs AS
SELECT
    utc.ConfigID,
    u.UserID,
    u.Username,
    u.TelegramChatID,
    c.ChainName,
    c.ChainID,
    tp.PairName,
    bt.Symbol AS BaseToken,
    qt.Symbol AS QuoteToken,
    utc.TradePercentage,
    utc.TriggerPercentage,
    utc.MaxAmount,
    utc.MinimumAmount,
    utc.Multiplier,
    utc.IsActive
FROM UserTradingConfigs utc
INNER JOIN Users u ON utc.UserID = u.UserID
INNER JOIN TradingPairs tp ON utc.PairID = tp.PairID
INNER JOIN Chains c ON tp.ChainID = c.ChainID
INNER JOIN Tokens bt ON tp.BaseTokenID = bt.TokenID
INNER JOIN Tokens qt ON tp.QuoteTokenID = qt.TokenID
WHERE utc.IsActive = 1 AND u.IsActive = 1;

-- View: Trade Summary by User and Pair
CREATE VIEW IF NOT EXISTS vw_TradeSummaryByUserPair AS
SELECT
    t.UserID,
    u.Username,
    c.ChainName,
    c.ChainID,
    tp.PairName,
    COUNT(*) AS TotalTrades,
    SUM(CASE WHEN t.Action = 'BUY' THEN 1 ELSE 0 END) AS BuyCount,
    SUM(CASE WHEN t.Action = 'SELL' THEN 1 ELSE 0 END) AS SellCount,
    SUM(t.QuantitySent) AS TotalVolumeSent,
    SUM(t.QuantityReceived) AS TotalVolumeReceived,
    AVG(t.QuantitySent) AS AvgQuantitySent,
    MIN(t.CreatedAt) AS FirstTradeDate,
    MAX(t.CreatedAt) AS LastTradeDate
FROM Trades t
INNER JOIN Users u ON t.UserID = u.UserID
INNER JOIN TradingPairs tp ON t.PairID = tp.PairID
INNER JOIN Chains c ON tp.ChainID = c.ChainID
GROUP BY t.UserID, u.Username, c.ChainName, c.ChainID, tp.PairName;

-- View: Latest Prices by Pair
CREATE VIEW IF NOT EXISTS vw_LatestPricesByPair AS
WITH RankedPrices AS (
    SELECT
        ph.PairID,
        tp.PairName,
        c.ChainName,
        c.ChainID,
        ph.Price,
        ph.CreatedAt,
        ROW_NUMBER() OVER (PARTITION BY ph.PairID ORDER BY ph.CreatedAt DESC) AS rn
    FROM PriceHistory ph
    INNER JOIN TradingPairs tp ON ph.PairID = tp.PairID
    INNER JOIN Chains c ON tp.ChainID = c.ChainID
)
SELECT
    PairID,
    PairName,
    ChainName,
    ChainID,
    Price,
    CreatedAt
FROM RankedPrices
WHERE rn = 1;

-- View: User Balances with Token Details
CREATE VIEW IF NOT EXISTS vw_UserBalances AS
SELECT
    ub.UserID,
    u.Username,
    c.ChainName,
    t.Symbol AS TokenSymbol,
    t.TokenAddress,
    ub.Balance,
    ub.CreatedAt AS LastUpdated
FROM UserBalances ub
INNER JOIN Users u ON ub.UserID = u.UserID
INNER JOIN Tokens t ON ub.TokenID = t.TokenID
INNER JOIN Chains c ON t.ChainID = c.ChainID;

-- View: Trade Details with Metrics
CREATE VIEW IF NOT EXISTS vw_TradeDetails AS
SELECT
    t.TradeID,
    t.UserID,
    u.Username,
    tp.PairName,
    c.ChainName,
    t.Action,
    ph.Price,
    t.QuantitySent,
    t.QuantityReceived,
    tm.ConsecutiveCount,
    tm.ActualTradePercentage,
    t.TxHash,
    t.CreatedAt
FROM Trades t
INNER JOIN Users u ON t.UserID = u.UserID
INNER JOIN TradingPairs tp ON t.PairID = tp.PairID
INNER JOIN Chains c ON tp.ChainID = c.ChainID
INNER JOIN PriceHistory ph ON t.PriceID = ph.PriceID
LEFT JOIN TradeMetrics tm ON t.TradeID = tm.TradeID;

-- =============================================
-- SCHEMA SUMMARY
-- =============================================
-- Total Tables: 10
--   1. Chains
--   2. Users
--   3. Tokens
--   4. TradingPairs
--   5. UserTradingConfigs
--   6. PriceHistory
--   7. Trades
--   8. TradeMetrics
--   9. UserBalances
--   10. Suggestions
--
-- Total Indexes: 26
-- Total Views: 5
-- Common Data Included: 3 Chains, 3 Tokens (Hyperion Testnet)

// filepath: database\sqlreference.txt
(BINARY FILE SKIPPED)

// filepath: lt_tg\README.md
# LazaiTrader Telegram Bot - Cloudflare Worker

A simple Telegram bot menu interface deployed as a Cloudflare Worker. All menu items currently return "TODO" messages as placeholders.

## Features

- âœ… Webhook-based Telegram bot (no polling needed)
- âœ… Serverless deployment on Cloudflare Workers
- âœ… Menu structure with inline keyboards
- âœ… All commands return TODO placeholders
- âœ… No backend integration (pure UI/menu)

## Commands

- `/start` - Show welcome message and main menu
- `/wallet` - TODO: Show wallet addresses
- `/balance` - TODO: Check balances
- `/withdraw` - TODO: Withdraw funds
- `/config` - Show trading pair selection menu (TODO)
- `/myconfig` - TODO: View strategies
- `/deleteconfig` - Show delete config menu (TODO)
- `/chart` - TODO: View trade history
- `/contribute` - TODO: Share trading data
- `/suggestion` - TODO: Get strategy suggestions
- `/help` - Show available commands

## Prerequisites

1. **Cloudflare Account** - Sign up at [cloudflare.com](https://cloudflare.com)
2. **Telegram Bot Token** - Create a bot via [@BotFather](https://t.me/botfather)
3. **Node.js** - Install from [nodejs.org](https://nodejs.org)
4. **Wrangler CLI** - Cloudflare Workers CLI tool

## Setup Instructions

### 1. Install Dependencies

```bash
cd cloudflare/lt_tg
npm install
```

### 2. Configure Wrangler

Login to Cloudflare:

```bash
npx wrangler login
```

### 3. Set Bot Token

Add your Telegram Bot Token as a secret:

```bash
npx wrangler secret put BOT_TOKEN
```

When prompted, paste your bot token from BotFather.

### 4. Deploy to Cloudflare Workers

```bash
npm run deploy
```

This will deploy your worker and give you a URL like:
```
https://lazaitrader-tg-bot.your-subdomain.workers.dev
```

### 5. Set Telegram Webhook

Tell Telegram to send updates to your worker:

```bash
curl -X POST "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/setWebhook" \
  -H "Content-Type: application/json" \
  -d '{"url": "https://lazaitrader-tg-bot.your-subdomain.workers.dev"}'
```

Replace:
- `<YOUR_BOT_TOKEN>` with your actual bot token
- `lazaitrader-tg-bot.your-subdomain.workers.dev` with your actual worker URL

### 6. Test Your Bot

Open Telegram and send `/start` to your bot. You should see the welcome message and menu!

## Development

### Local Development

Test your worker locally:

```bash
npm run dev
```

This starts a local server on `http://localhost:8787`

**Note:** For local testing with Telegram, you'll need to use a tunneling service like [ngrok](https://ngrok.com) to expose your local server.

### View Logs

Monitor your worker in real-time:

```bash
npm run tail
```

## Project Structure

```
cloudflare/lt_tg/
â”œâ”€â”€ worker.js          # Main Cloudflare Worker code
â”œâ”€â”€ wrangler.toml      # Cloudflare Workers configuration
â”œâ”€â”€ package.json       # Node.js dependencies
â””â”€â”€ README.md          # This file
```

## How It Works

1. **Webhook**: Telegram sends updates to your Cloudflare Worker URL
2. **Worker**: Processes the update and routes to appropriate handler
3. **Response**: Worker calls Telegram API to send messages back
4. **TODO Placeholders**: All actions currently return "TODO" messages

## Next Steps (Future Implementation)

To add actual functionality, you'll need to:

1. **Add Storage**: Use Cloudflare KV or D1 for user data
2. **Add API Integration**: Connect to blockchain APIs
3. **Add Business Logic**: Implement wallet management, trading, etc.
4. **Add Authentication**: Verify user ownership of wallets
5. **Add Security**: Rate limiting, input validation, etc.

## Troubleshooting

### Bot doesn't respond

1. Check webhook is set correctly:
   ```bash
   curl "https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getWebhookInfo"
   ```

2. Check worker logs:
   ```bash
   npm run tail
   ```

3. Verify bot token is set:
   ```bash
   npx wrangler secret list
   ```

### Deploy fails

- Make sure you're logged in: `npx wrangler login`
- Check your wrangler.toml configuration
- Verify you have a Cloudflare account with Workers enabled

### Webhook errors

- Ensure your worker URL is HTTPS (Cloudflare provides this automatically)
- Check that your worker is deployed and accessible
- Verify the webhook URL matches your worker URL exactly

## Resources

- [Cloudflare Workers Docs](https://developers.cloudflare.com/workers/)
- [Telegram Bot API](https://core.telegram.org/bots/api)
- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/)

## License

MIT

// filepath: lt_tg\package.json
(BINARY FILE SKIPPED)

// filepath: lt_tg\worker.js
/**
 * LazaiTrader Telegram Bot - Cloudflare Worker
 * Main entry point with deposit command support
 * 
 * Responsibilities:
 * - Handle all Telegram interactions
 * - Call lt_tg_deposit worker for blockchain operations
 * - Display responses to users
 * - Handle all error messages and user guidance
 */

const TELEGRAM_API = 'https://api.telegram.org/bot';

// Bot commands configuration
const COMMANDS = [
  { command: 'start', description: 'ðŸš€ Register with LazaiTrader' },
  { command: 'wallet', description: 'ðŸ“‹ Show wallet addresses' },
  { command: 'balance', description: 'ðŸ’° Check balances' },
  { command: 'deposit', description: 'ðŸ“¥ Deposit to Smart Wallet' },
  { command: 'withdraw', description: 'ðŸ’¸ Withdraw funds' },
  { command: 'config', description: 'âš™ï¸ Configure strategy' },
  { command: 'myconfig', description: 'ðŸ“Š View strategies' },
  { command: 'deleteconfig', description: 'ðŸ—‘ï¸ Delete strategy' },
  { command: 'chart', description: 'ðŸ“ˆ View trade history' },
  { command: 'contribute', description: 'ðŸ“ˆ Share trading data' },
  { command: 'suggestion', description: 'ðŸ”® Get strategy suggestions' },
  { command: 'help', description: 'â“ Show help menu' }
];

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // Handle GET request for setup endpoint
    if (request.method === 'GET' && url.pathname === '/setup') {
      return await handleSetup(env);
    }

    // Only accept POST requests from Telegram for webhook
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }

    try {
      const update = await request.json();

      // Handle both messages and callback queries
      if (update.message) {
        await handleMessage(update.message, env);
      } else if (update.callback_query) {
        await handleCallbackQuery(update.callback_query, env);
      }

      return new Response('OK', { status: 200 });
    } catch (error) {
      console.error('Error processing update:', error);
      return new Response('Internal Server Error', { status: 500 });
    }
  }
};

/**
 * Handle setup - sets bot commands menu
 */
async function handleSetup(env) {
  const url = `${TELEGRAM_API}${env.BOT_TOKEN}/setMyCommands`;

  const payload = {
    commands: COMMANDS
  };

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const result = await response.json();

    if (result.ok) {
      return new Response(JSON.stringify({
        success: true,
        message: 'Bot commands menu has been set successfully!',
        commands: COMMANDS
      }), {
        headers: { 'Content-Type': 'application/json' },
        status: 200
      });
    } else {
      return new Response(JSON.stringify({
        success: false,
        error: result.description
      }), {
        headers: { 'Content-Type': 'application/json' },
        status: 500
      });
    }
  } catch (error) {
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), {
      headers: { 'Content-Type': 'application/json' },
      status: 500
    });
  }
}

/**
 * Handle incoming messages
 */
async function handleMessage(message, env) {
  const chatId = message.chat.id;
  const userId = message.from.id;
  const username = message.from.username || '';
  const text = message.text || '';
  const command = text.split(' ')[0].replace('/', '');

  // Route to appropriate handler
  switch (command) {
    case 'start':
      // Route to START_WORKER via service binding
      await callWorker(env, 'START_WORKER', 'start', chatId, userId, username, text);
      break;
    case 'deposit':
      await handleDeposit(chatId, userId, env);
      break;
    case 'wallet':
      await sendTodoMessage(chatId, env, 'Wallet');
      break;
    case 'balance':
      await sendTodoMessage(chatId, env, 'Balance');
      break;
    case 'withdraw':
      await sendTodoMessage(chatId, env, 'Withdraw');
      break;
    case 'config':
      await handleConfig(chatId, env);
      break;
    case 'myconfig':
      await sendTodoMessage(chatId, env, 'My Config');
      break;
    case 'deleteconfig':
      await handleDeleteConfig(chatId, env);
      break;
    case 'chart':
      await sendTodoMessage(chatId, env, 'Chart');
      break;
    case 'contribute':
      await sendTodoMessage(chatId, env, 'Contribute');
      break;
    case 'suggestion':
      await sendTodoMessage(chatId, env, 'Suggestion');
      break;
    case 'help':
      await handleHelp(chatId, env);
      break;
    default:
      // Unknown command
      await sendMessage(chatId, env, {
        text: 'â“ Unknown command. Use /help to see available commands.'
      });
  }
}

/**
 * Handle /deposit command - initiate deposit flow
 */
async function handleDeposit(chatId, userId, env) {
  try {
    // Check if user is registered and has a wallet
    const user = await env.DB.prepare(
      'SELECT UserID, UserWallet FROM Users WHERE UserID = ?'
    ).bind(userId).first();

    if (!user) {
      await sendMessage(chatId, env, {
        text: 'âŒ You are not registered yet. Please use /start to register first.'
      });
      return;
    }

    if (!user.UserWallet) {
      await sendMessage(chatId, env, {
        text: 'âŒ No wallet found. Please use /start to complete registration.'
      });
      return;
    }

    // Get active chains with RPC endpoints
    const chains = await env.DB.prepare(
      'SELECT ChainID, ChainName, RPCEndpoint FROM Chains WHERE IsActive = 1 ORDER BY ChainID'
    ).all();

    if (!chains.results || chains.results.length === 0) {
      await sendMessage(chatId, env, {
        text: 'âŒ No active chains available at the moment.'
      });
      return;
    }

    // Build keyboard with active chains
    const keyboard = {
      inline_keyboard: chains.results.map(chain => [
        { text: `ðŸ”— ${chain.ChainName}`, callback_data: `deposit_chain_${chain.ChainID}` }
      ])
    };

    await sendMessage(chatId, env, {
      text: `ðŸ“¥ *Select a chain to deposit to:*\n\nChoose which blockchain network you want to use for your Smart Contract Wallet:`,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  } catch (error) {
    console.error('Error in handleDeposit:', error);
    await sendMessage(chatId, env, {
      text: 'âŒ An error occurred. Please try again later.'
    });
  }
}

/**
 * Handle callback queries from inline keyboards
 */
async function handleCallbackQuery(callbackQuery, env) {
  const chatId = callbackQuery.message.chat.id;
  const messageId = callbackQuery.message.message_id;
  const userId = callbackQuery.from.id;
  const data = callbackQuery.data;

  // Answer callback query to remove loading state
  await answerCallbackQuery(callbackQuery.id, env);

  // Handle different callback actions
  if (data.startsWith('deposit_chain_')) {
    const chainId = parseInt(data.replace('deposit_chain_', ''));
    await handleDepositChain(chatId, userId, chainId, env);
  } else if (data.startsWith('pair_')) {
    await editMessage(chatId, messageId, env, {
      text: 'ðŸ“Š *TODO: Pair Selection*\n\nThis feature will allow you to select trading pairs.',
      parse_mode: 'Markdown'
    });
  } else if (data.includes('risk')) {
    await editMessage(chatId, messageId, env, {
      text: 'âš–ï¸ *TODO: Risk Level*\n\nThis feature will allow you to configure risk settings.',
      parse_mode: 'Markdown'
    });
  } else if (data.startsWith('del_')) {
    await editMessage(chatId, messageId, env, {
      text: 'ðŸ—‘ï¸ *TODO: Delete Config*\n\nThis feature will allow you to delete configurations.',
      parse_mode: 'Markdown'
    });
  }
}

/**
 * Handle deposit chain selection - call deposit worker
 */
async function handleDepositChain(chatId, userId, chainId, env) {
  try {
    // Get user wallet and chain info
    const user = await env.DB.prepare(
      'SELECT UserWallet FROM Users WHERE UserID = ?'
    ).bind(userId).first();

    if (!user || !user.UserWallet) {
      await sendMessage(chatId, env, {
        text: 'âŒ User wallet not found. Please try /start again.'
      });
      return;
    }

    const chain = await env.DB.prepare(
      'SELECT ChainID, ChainName, RPCEndpoint FROM Chains WHERE ChainID = ? AND IsActive = 1'
    ).bind(chainId).first();

    if (!chain) {
      await sendMessage(chatId, env, {
        text: 'âŒ Chain not available or inactive.'
      });
      return;
    }

    // Show loading message
    await sendMessage(chatId, env, {
      text: `â³ *Processing Deposit for ${chain.ChainName}...*\n\nSetting up your Smart Contract Wallet...`,
      parse_mode: 'Markdown'
    });

    // Call deposit worker
    const depositResult = await callDepositWorker(
      userId,
      user.UserWallet,
      chainId,
      chain.RPCEndpoint,
      env
    );

    if (!depositResult.success) {
      // Handle errors
      await handleDepositError(chatId, depositResult.errorCode, depositResult.error, chain, env);
      return;
    }

    // Success - display deposit address
    await displayDepositAddress(
      chatId,
      user.UserWallet,
      depositResult.scwAddress,
      chain,
      env
    );

  } catch (error) {
    console.error('Error in handleDepositChain:', error);
    await sendMessage(chatId, env, {
      text: 'âŒ An error occurred. Please try again later.'
    });
  }
}

/**
 * Call the deposit worker (blockchain backend)
 */
async function callDepositWorker(userId, userWallet, chainId, rpcUrl, env) {
  try {
    const response = await env.DEPOSIT_WORKER.fetch('https://internal/scw-deploy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        userId: userId,
        userWallet: userWallet,
        chainId: chainId,
        rpcUrl: rpcUrl
      })
    });

    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Error calling deposit worker:', error);
    return {
      success: false,
      error: error.message,
      errorCode: 'WORKER_ERROR'
    };
  }
}

/**
 * Handle deposit errors with user-friendly messages
 */
async function handleDepositError(chatId, errorCode, errorMessage, chain, env) {
  let message = '';

  switch (errorCode) {
    case 'DEPLOYMENT_FAILED':
      message = `âŒ *Failed to Deploy Smart Contract Wallet*\n\nThe deployment failed after 2 attempts.\n\nðŸ“§ *Contact Support:*\nâ€¢ @LazaiTraderDev\nâ€¢ support@lazaitrader.com\n\nðŸ’¡ *You can try again in a few moments.*`;
      break;
    case 'CONFIG_ERROR':
      message = `âŒ *Service Configuration Error*\n\nOur system is experiencing a temporary issue.\n\nðŸ“§ *Contact Support:*\nâ€¢ @LazaiTraderDev\nâ€¢ support@lazaitrader.com`;
      break;
    case 'INVALID_INPUT':
      message = `âŒ *Invalid Input*\n\nPlease try again with the /deposit command.`;
      break;
    default:
      message = `âŒ *Error: ${errorMessage}*\n\nðŸ“§ *Contact Support:*\nâ€¢ @LazaiTraderDev\nâ€¢ support@lazaitrader.com`;
  }

  await sendMessage(chatId, env, {
    text: message,
    parse_mode: 'Markdown'
  });
}

/**
 * Display deposit address with instructions
 */
async function displayDepositAddress(chatId, userWallet, scwAddress, chain, env) {
  // Get supported tokens for this chain
  const tokens = await env.DB.prepare(
    'SELECT Symbol FROM Tokens WHERE ChainID = ? AND IsActive = 1 ORDER BY Symbol'
  ).bind(chain.ChainID).all();

  const tokenList = tokens?.results?.map(t => `â€¢ ${t.Symbol}`).join('\n') || '(Loading...)';

  const message = `
âœ… *Smart Contract Wallet Ready!*

ðŸ”— *Network:* ${chain.ChainName}
ðŸ“¬ *Your Deposit Address:*
\`${scwAddress}\`

ðŸ’° *Supported Tokens on ${chain.ChainName}:*
${tokenList}

ðŸ“‹ *How to Deposit:*
1ï¸âƒ£ Copy the wallet address above
2ï¸âƒ£ Go to your exchange or wallet
3ï¸âƒ£ Send tokens to this address on ${chain.ChainName}
4ï¸âƒ£ Wait for blockchain confirmation
5ï¸âƒ£ Your funds will appear in your trading wallet

âš ï¸ *IMPORTANT:*
ðŸ”´ Only send tokens to this address on ${chain.ChainName}
ðŸ”´ Sending to this address on OTHER networks = LOST FUNDS
ðŸ”´ Always double-check the address before sending

ðŸ“Š *Your Wallets:*
â€¢ EOA: \`${userWallet}\` (your external wallet)
â€¢ SCW: \`${scwAddress}\` (your trading wallet)

â“ *Need Help?*
Use /help or contact: support@lazaitrader.com
`;

  await sendMessage(chatId, env, {
    text: message.trim(),
    parse_mode: 'Markdown'
  });
}

/**
 * Handle /config command - show trading pair options
 */
async function handleConfig(chatId, env) {
  const keyboard = {
    inline_keyboard: [
      [{ text: 'ðŸŸ¢ tgMetis-tgUSDC', callback_data: 'pair_tgmetis_tgusdc' }],
      [{ text: 'ðŸŸ¢ tgETH-tgUSDC', callback_data: 'pair_tgeth_tgusdc' }],
      [{ text: 'ðŸ”’ Metis-USDC', callback_data: 'pair_metis_usdc' }],
      [{ text: 'ðŸ”’ ETH-USDC', callback_data: 'pair_eth_usdc' }]
    ]
  };

  await sendMessage(chatId, env, {
    text: `âš™ï¸ *Let's Set Up Your Trading Strategy!*

First, choose which crypto pair you want to trade.

*Available on Testnet:*
ðŸŸ¢ = Active and ready
ðŸ”’ = Coming soon

Select a trading pair:`,
    parse_mode: 'Markdown',
    reply_markup: keyboard
  });
}

/**
 * Handle /deleteconfig command
 */
async function handleDeleteConfig(chatId, env) {
  const keyboard = {
    inline_keyboard: [
      [{ text: 'Delete tgMetis-tgUSDC', callback_data: 'del_tgMetis_tgUSDC' }],
      [{ text: 'Delete tgETH-tgUSDC', callback_data: 'del_tgETH_tgUSDC' }]
    ]
  };

  await sendMessage(chatId, env, {
    text: 'ðŸ—‘ï¸ *Select Configuration to Delete*',
    parse_mode: 'Markdown',
    reply_markup: keyboard
  });
}

/**
 * Handle /help command
 */
async function handleHelp(chatId, env) {
  const commandList = COMMANDS.map(cmd => `/${cmd.command} - ${cmd.description}`).join('\n');

  await sendMessage(chatId, env, {
    text: `â“ *Available Commands:*\n\n${commandList}\n\nðŸ’¡ *Tip:* Use the inline menu buttons for quick access!`,
    parse_mode: 'Markdown'
  });
}

/**
 * Send a generic TODO message
 */
async function sendTodoMessage(chatId, env, feature) {
  await sendMessage(chatId, env, {
    text: `âœ… *TODO: ${feature}*\n\nThis feature is not yet implemented.`,
    parse_mode: 'Markdown'
  });
}

/**
 * Send a message to Telegram
 */
async function sendMessage(chatId, env, options) {
  const url = `${TELEGRAM_API}${env.BOT_TOKEN}/sendMessage`;

  const payload = {
    chat_id: chatId,
    ...options
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  return await response.json();
}

/**
 * Edit an existing message
 */
async function editMessage(chatId, messageId, env, options) {
  const url = `${TELEGRAM_API}${env.BOT_TOKEN}/editMessageText`;

  const payload = {
    chat_id: chatId,
    message_id: messageId,
    ...options
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  return await response.json();
}

/**
 * Answer a callback query
 */
async function answerCallbackQuery(callbackQueryId, env) {
  const url = `${TELEGRAM_API}${env.BOT_TOKEN}/answerCallbackQuery`;

  const payload = {
    callback_query_id: callbackQueryId
  };

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  return await response.json();
}

/**
 * Call another worker via service binding
 */
async function callWorker(env, workerBinding, action, chatId, userId, username, text) {
  try {
    const response = await env[workerBinding].fetch('https://internal/action', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: action,
        chatId: chatId,
        userId: userId,
        username: username,
        text: text
      })
    });

    return await response.json();
  } catch (error) {
    console.error(`Error calling ${workerBinding}:`, error);
    throw error;
  }
}

// filepath: lt_tg\wrangler.toml
name = "lt_tg"
main = "worker.js"
compatibility_date = "2024-01-01"
type = "module"

# D1 Database Binding
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader"
database_id = "64791295-2134-4306-a6e9-4a45619aab05"

# Service Bindings - Deposit Worker
[[services]]
binding = "DEPOSIT_WORKER"
service = "lt-tg-deposit"

# START_WORKER Service Binding (if it exists)
[[services]]
binding = "START_WORKER"
service = "lt-tg-start"

# Bind account-level secrets to this worker
[[secrets_store_secrets]]
binding = "BOT_TOKEN"
store_id = "624605538ad54f809d07c4424d7dd2d1"
secret_name = "BOT_TOKEN"

[[secrets_store_secrets]]
binding = "FACTORY_CONTRACT_ADDRESS"
store_id = "624605538ad54f809d07c4424d7dd2d1"
secret_name = "FACTORY_CONTRACT_ADDRESS"

[[secrets_store_secrets]]
binding = "BOT_PRIVATE_KEY"
store_id = "624605538ad54f809d07c4424d7dd2d1"
secret_name = "BOT_PRIVATE_KEY"

[env.production]
# Production environment settings

[observability]
[observability.logs]
enabled = true
head_sampling_rate = 1
invocation_logs = true
persist = true

// filepath: lt_tg_deposit\package.json
(BINARY FILE SKIPPED)

// filepath: lt_tg_deposit\worker.js
/**
 * LazaiTrader Deposit Worker - Cloudflare Worker
 * Pure blockchain backend for Smart Contract Wallet deployment
 * 
 * Responsibilities:
 * - Deploy SCW on blockchain
 * - Retrieve existing SCW addresses
 * - Return structured responses (success/error)
 * - NO Telegram interaction
 * 
 * Input format:
 * {
 *   userId: number,
 *   userWallet: string (0x...),
 *   chainId: number,
 *   rpcUrl: string
 * }
 * 
 * Output format:
 * {
 *   success: boolean,
 *   scwAddress?: string,
 *   error?: string,
 *   errorCode?: string
 * }
 */

import { ethers } from 'ethers';

// Factory Contract ABI
const FACTORY_ABI = [
  {
    inputs: [{ name: '_owner', type: 'address' }],
    name: 'createWallet',
    outputs: [{ name: 'wallet', type: 'address' }],
    stateMutability: 'nonpayable',
    type: 'function'
  },
  {
    inputs: [{ name: '_user', type: 'address' }],
    name: 'userWallets',
    outputs: [{ name: '', type: 'address' }],
    stateMutability: 'view',
    type: 'function'
  },
  {
    inputs: [{ name: '_user', type: 'address' }],
    name: 'hasWallet',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'view',
    type: 'function'
  }
];

export default {
  async fetch(request, env) {
    if (request.method !== 'POST') {
      return jsonResponse({ error: 'Method not allowed' }, 405);
    }

    try {
      const payload = await request.json();
      const { userId, userWallet, chainId, rpcUrl } = payload;

      // Validate input
      if (!userId || !userWallet || !chainId || !rpcUrl) {
        return jsonResponse({
          success: false,
          error: 'Missing required parameters',
          errorCode: 'INVALID_INPUT'
        }, 400);
      }

      // Get secrets from Cloudflare Secrets Store
      const botPrivateKey = await env.BOT_PRIVATE_KEY.get();
      const factoryContractAddress = await env.FACTORY_CONTRACT_ADDRESS_HYPERION.get();

      if (!botPrivateKey || !factoryContractAddress) {
        console.error('Missing blockchain configuration');
        return jsonResponse({
          success: false,
          error: 'Service configuration error',
          errorCode: 'CONFIG_ERROR'
        }, 500);
      }

      // Check existing SCW in database
      const existingScw = await getExistingSCW(userId, chainId, env);
      if (existingScw) {
        return jsonResponse({
          success: true,
          scwAddress: existingScw,
          isNew: false
        });
      }

      // Deploy new SCW
      let scwAddress = await deploySCW(
        userWallet,
        factoryContractAddress,
        botPrivateKey,
        rpcUrl,
        chainId
      );

      if (!scwAddress) {
        // Retry once
        console.log('ðŸ”„ First deployment attempt failed, retrying...');
        await new Promise(resolve => setTimeout(resolve, 2000));

        scwAddress = await deploySCW(
          userWallet,
          factoryContractAddress,
          botPrivateKey,
          rpcUrl,
          chainId
        );

        if (!scwAddress) {
          return jsonResponse({
            success: false,
            error: 'Failed to deploy Smart Contract Wallet after 2 attempts',
            errorCode: 'DEPLOYMENT_FAILED'
          }, 500);
        }
      }

      // Store in database
      await storeSCWInDatabase(userId, chainId, scwAddress, env);

      return jsonResponse({
        success: true,
        scwAddress: scwAddress,
        isNew: true
      });

    } catch (error) {
      console.error('Deposit worker error:', error);
      return jsonResponse({
        success: false,
        error: error.message,
        errorCode: 'INTERNAL_ERROR'
      }, 500);
    }
  }
};

/**
 * Check if SCW already exists in database
 */
async function getExistingSCW(userId, chainId, env) {
  try {
    const result = await env.DB.prepare(
      'SELECT SCWAddress FROM SCWDeployments WHERE UserID = ? AND ChainID = ?'
    ).bind(userId, chainId).first();

    return result?.SCWAddress || null;
  } catch (error) {
    console.error('Error checking existing SCW:', error);
    return null;
  }
}

/**
 * Deploy Smart Contract Wallet on blockchain
 */
async function deploySCW(userWallet, factoryAddress, botPrivateKey, rpcUrl, chainId) {
  try {
    console.log(`ðŸš€ Deploying SCW for user on chain ${chainId}`);

    // Initialize ethers.js
    const provider = new ethers.JsonRpcProvider(rpcUrl);
    const signer = new ethers.Wallet(botPrivateKey, provider);

    console.log(`âœ“ Connected to RPC`);
    console.log(`âœ“ Bot account: ${signer.address}`);

    // Initialize factory contract
    const factoryContract = new ethers.Contract(
      factoryAddress,
      FACTORY_ABI,
      signer
    );

    // Check if wallet already exists on-chain
    const hasWallet = await factoryContract.hasWallet(userWallet);

    if (hasWallet) {
      const existingWallet = await factoryContract.userWallets(userWallet);
      console.log(`âœ“ SCW already exists on-chain: ${existingWallet}`);
      return existingWallet;
    }

    // Deploy new SCW
    console.log('ðŸ“ Creating transaction...');
    const tx = await factoryContract.createWallet(userWallet);
    console.log(`âœ“ Transaction sent: ${tx.hash}`);

    // Wait for transaction (5 minute timeout)
    console.log('â³ Waiting for confirmation (max 5 minutes)...');
    const receipt = await waitForTransaction(provider, tx.hash, 300000);

    if (!receipt) {
      console.error('âŒ Transaction timeout');
      return null;
    }

    if (receipt.status !== 1) {
      console.error(`âŒ Transaction failed with status ${receipt.status}`);
      return null;
    }

    console.log(`âœ“ Transaction confirmed: ${tx.hash}`);

    // Get deployed SCW address
    const scwAddress = await factoryContract.userWallets(userWallet);

    if (!scwAddress || scwAddress === '0x0000000000000000000000000000000000000000') {
      console.error('âŒ Failed to retrieve SCW address');
      return null;
    }

    console.log(`âœ… SCW deployed successfully: ${scwAddress}`);
    return scwAddress;

  } catch (error) {
    console.error('âŒ SCW deployment error:', error.message);
    return null;
  }
}

/**
 * Wait for transaction with timeout
 */
async function waitForTransaction(provider, txHash, timeoutMs = 300000) {
  try {
    return await Promise.race([
      provider.waitForTransaction(txHash),
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), timeoutMs)
      )
    ]);
  } catch (error) {
    console.error('Transaction wait error:', error.message);
    return null;
  }
}

/**
 * Store SCW in database
 */
async function storeSCWInDatabase(userId, chainId, scwAddress, env) {
  try {
    // Update Users table
    await env.DB.prepare(
      'UPDATE Users SET SCWAddress = ? WHERE UserID = ?'
    ).bind(scwAddress, userId).run();

    // Insert into SCWDeployments
    await env.DB.prepare(
      `INSERT INTO SCWDeployments (UserID, ChainID, SCWAddress, DeploymentStatus, DeployedAt) 
       VALUES (?, ?, ?, 'success', datetime('now'))`
    ).bind(userId, chainId, scwAddress).run();

    console.log(`âœ“ SCW stored in database for user ${userId}`);
  } catch (error) {
    console.error('Error storing SCW in database:', error);
    // Don't throw - SCW was deployed successfully, just DB logging failed
  }
}

/**
 * Helper: Return JSON response
 */
function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json' }
  });
}

// filepath: lt_tg_deposit\wrangler.toml
name = "lt_tg_deposit"
main = "worker.js"
compatibility_date = "2024-01-01"
type = "module"

# D1 Database Binding (same database as main worker)
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader"
database_id = "64791295-2134-4306-a6e9-4a45619aab05"

# ============================================
# Cloudflare Secrets Store Bindings
# Same account-level secrets as main worker
# They must be created in Cloudflare Secrets Store first
# ============================================

[[secrets_store_secrets]]
binding = "BOT_PRIVATE_KEY"
store_id = "624605538ad54f809d07c4424d7dd2d1"
secret_name = "BOT_PRIVATE_KEY"

[[secrets_store_secrets]]
binding = "FACTORY_CONTRACT_ADDRESS_HYPERION"
store_id = "624605538ad54f809d07c4424d7dd2d1"
secret_name = "FACTORY_CONTRACT_ADDRESS_HYPERION"

[env.production]
# Production environment settings

[observability]
[observability.logs]
enabled = true
head_sampling_rate = 1
invocation_logs = true
persist = true

// filepath: lt_tg_start\README.md
# LazaiTrader Registration Worker

Internal microservice that handles user registration and wallet verification.

## Security Model

### Service Binding Architecture

This worker is **ONLY** accessible via Service Binding from the main `lt_tg` worker. It is **NOT** publicly accessible.

**Security Features:**
- âœ… No public routes - cannot be called directly from internet
- âœ… Only callable by `lt_tg` worker via Service Binding
- âœ… D1 database access restricted to workers only
- âœ… Wallet address validation and sanitization
- âœ… Duplicate registration prevention
- âœ… Session-based registration flow tracking

### How Service Bindings Work

```
Internet â†’ Telegram API â†’ lt_tg worker â†’ (Service Binding) â†’ lt_tg_start worker â†’ D1 Database
```

- Users interact with Telegram
- Telegram sends webhooks to `lt_tg`
- `lt_tg` routes registration requests to `lt_tg_start` via internal Service Binding
- `lt_tg_start` handles registration logic and database operations
- No direct public access to `lt_tg_start`

## Features

### User Registration Flow

1. **New User - /start command**
   - Shows friendly intro to LazaiTrader
   - Explains wallet requirements in non-technical terms
   - Requests EOA (Ethereum wallet) address
   - Creates registration session

2. **Wallet Verification**
   - Validates Ethereum address format
   - Checks for duplicate registrations
   - Stores user data in D1 database
   - Sends confirmation with next steps

3. **Returning User - /start command**
   - Welcome back message
   - Shows registered wallet address
   - Quick links to main features

## Database Tables Used

### Users
Stores registered user information:
- `UserID` - Telegram user ID
- `UserWallet` - EOA wallet address
- `TelegramChatID` - Telegram chat ID
- `Username` - Telegram username
- `RegisteredAt` - Registration timestamp
- `SCWAddress` - Smart Contract Wallet (added later)

### RegistrationSessions
Temporary session tracking:
- `UserID` - Telegram user ID
- `State` - Current state ('awaiting_wallet')
- `CreatedAt` - Session creation time
- Automatically deleted after successful registration

## Setup Instructions

### 1. Prerequisites

- D1 database named `lazaitrader` must be created
- `lt_tg` worker must be deployed first
- Both workers need BOT_TOKEN secret

### 2. Run Database Migration

Add the RegistrationSessions table:

```bash
wrangler d1 execute lazaitrader --file=../database/migration_registration_sessions.sql
```

### 3. Update Configuration

Edit `wrangler.toml` and replace `YOUR_DATABASE_ID_HERE` with your actual D1 database ID:

```toml
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader"
database_id = "abc123..."  # Your actual database ID
```

### 4. Set Bot Token

```bash
wrangler secret put BOT_TOKEN
```

Paste the same bot token used in `lt_tg` worker.

### 5. Deploy Worker

```bash
npm run deploy
```

### 6. Update Main Worker

Ensure `lt_tg/wrangler.toml` has the Service Binding:

```toml
[[services]]
binding = "START_WORKER"
service = "lt-tg-start"
```

### 7. Redeploy Main Worker

```bash
cd ../lt_tg
npm run deploy
```

## API Interface

This worker is called internally by `lt_tg` via Service Binding.

### Request Format

```javascript
POST https://internal/start
Content-Type: application/json

{
  "action": "start" | "verify_wallet",
  "chatId": 123456789,
  "userId": 123456789,
  "username": "telegram_username",
  "text": "0x..." // for verify_wallet action
}
```

### Response Format

```javascript
{
  "success": true,
  "registered": true | false,
  "awaiting": "wallet" // if awaiting input
}
```

## Validation Logic

### Ethereum Address Validation

```javascript
âœ… Must start with "0x"
âœ… Must be exactly 42 characters
âœ… Must contain only hex characters (0-9, A-F)
âœ… Case-insensitive comparison for duplicates
```

### Duplicate Prevention

```javascript
âœ… Check UserID - one account per Telegram user
âœ… Check UserWallet - one account per wallet address
```

## Error Handling

The worker handles various error scenarios:

1. **Invalid Wallet Format**
   - User-friendly error message
   - Example of correct format
   - Prompt to try again

2. **Duplicate Wallet**
   - Clear explanation
   - Suggest alternative wallet
   - Contact support option

3. **Database Errors**
   - Generic error message to user
   - Detailed error logged for debugging
   - Graceful fallback

## User Experience

### Non-Technical User Friendly

Messages are designed for users who may not understand crypto terminology:

- âŒ "Provide your EOA address"
- âœ… "Send me your Ethereum wallet address (like your crypto bank account number)"

- âŒ "0x address required"
- âœ… "It starts with '0x' - copy it from your MetaMask or Trust Wallet app"

### Clear Next Steps

After registration, users immediately know:
- What they just did (registered)
- What they have (wallet linked)
- What to do next (set up strategy with /config)
- How to get help (/help command)

## Testing

### Test New Registration

1. Send `/start` to bot
2. Send a valid Ethereum address
3. Verify success message
4. Check database: `wrangler d1 execute lazaitrader --command="SELECT * FROM Users"`

### Test Duplicate Prevention

1. Register with wallet A
2. Try to register again with same wallet â†’ Should reject
3. Different user tries wallet A â†’ Should reject

### Test Invalid Wallet

1. Send `/start`
2. Send invalid address: "not-a-wallet"
3. Should show helpful error
4. Send valid address â†’ Should succeed

## Security Best Practices

### What This Worker Does

âœ… **Validates** - Checks wallet address format
âœ… **Sanitizes** - Normalizes addresses (lowercase)
âœ… **Protects** - Prevents duplicate registrations
âœ… **Logs** - Records errors for debugging
âœ… **Isolates** - No public access via Service Binding

### What This Worker Does NOT Do

âŒ Does not store private keys
âŒ Does not have withdrawal permissions
âŒ Does not deploy smart contracts (separate worker)
âŒ Does not access user funds

## Monitoring

### View Logs

```bash
wrangler tail lt-tg-start
```

### Key Metrics to Monitor

- Registration success rate
- Validation error frequency
- Duplicate wallet attempts
- Database query performance

## Troubleshooting

### Worker not receiving requests

1. Check Service Binding in `lt_tg/wrangler.toml`
2. Verify both workers deployed
3. Check `lt_tg` logs for routing errors

### Database errors

1. Verify D1 binding in `wrangler.toml`
2. Check database ID is correct
3. Ensure migration was run
4. Test with: `wrangler d1 execute lazaitrader --command="SELECT 1"`

### Bot not responding

1. Check BOT_TOKEN is set correctly
2. Verify Telegram API accessible
3. Check worker logs: `wrangler tail`

## Resources

- [Cloudflare Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/)
- [D1 Database Docs](https://developers.cloudflare.com/d1/)
- [Telegram Bot API](https://core.telegram.org/bots/api)

// filepath: lt_tg_start\package.json
(BINARY FILE SKIPPED)

// filepath: lt_tg_start\worker.js
/**
 * LazaiTrader Registration Worker
 * Handles user registration and wallet verification
 * Only callable via Service Binding from lt_tg worker
 */

const TELEGRAM_API = 'https://api.telegram.org/bot';

export default {
  async fetch(request, env) {
    // Only accept POST requests
    if (request.method !== 'POST') {
      return new Response('Method not allowed', { status: 405 });
    }

    try {
      const { action, chatId, userId, username, text } = await request.json();

      switch (action) {
        case 'start':
          return await handleStart(chatId, userId, username, env);
        case 'verify_wallet':
          return await handleWalletVerification(chatId, userId, username, text, env);
        default:
          return new Response(JSON.stringify({ error: 'Invalid action' }), {
            status: 400,
            headers: { 'Content-Type': 'application/json' }
          });
      }
    } catch (error) {
      console.error('Error in lt_tg_start worker:', error);
      return new Response(JSON.stringify({ error: error.message }), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
};

/**
 * Handle start command - check if user exists or show intro
 */
async function handleStart(chatId, userId, username, env) {
  try {
    // Check if user already exists
    const existingUser = await env.DB.prepare(
      'SELECT * FROM Users WHERE UserID = ?'
    ).bind(userId).first();

    if (existingUser) {
      // User already registered - welcome back
      const message = {
        chat_id: chatId,
        text: `ðŸ‘‹ *Welcome back, ${username || 'trader'}!*\n\n` +
          `Your account is active and ready to trade!\n\n` +
          `ðŸ“‹ *Your Details:*\n` +
          `ðŸ’¼ Your Wallet: \`${existingUser.UserWallet}\`\n` +
          (existingUser.SCWAddress ? `ðŸ” Trading Wallet: \`${existingUser.SCWAddress}\`\n\n` : '\n') +
          `*Quick Actions:*\n` +
          `ðŸ’° /balance - Check your funds\n` +
          `ðŸ“ˆ /chart - See your performance\n` +
          `âš™ï¸ /config - Set up trading strategy\n` +
          `ðŸ’¸ /withdraw - Cash out profits\n\n` +
          `ðŸ’¡ Ready to trade? Your AI is watching the markets 24/7!`,
        parse_mode: 'Markdown'
      };

      await sendMessage(env.BOT_TOKEN, message);

      return new Response(JSON.stringify({
        success: true,
        registered: true
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // New user - show intro and request wallet
    const introMessage = {
      chat_id: chatId,
      text: `ðŸŽ‰ *Welcome to LazaiTrader!*\n\n` +
        `I'm your AI-powered trading assistant. Here's how it works:\n\n` +
        `ðŸ¤– *Automated Trading*\n` +
        `â€¢ I trade for you 24/7 based on your strategy\n` +
        `â€¢ You stay in control - set your own rules\n` +
        `â€¢ No manual trading needed\n\n` +
        `ðŸ” *Your Funds, Your Control*\n` +
        `â€¢ You provide your wallet address\n` +
        `â€¢ We create a secure Smart Contract Wallet for trading\n` +
        `â€¢ Only YOU can withdraw - we can't touch your funds\n\n` +
        `ðŸ“Š *Smart Strategy*\n` +
        `â€¢ Set your risk level (conservative or aggressive)\n` +
        `â€¢ Define when to buy/sell automatically\n` +
        `â€¢ Track performance with real-time charts\n\n` +
        `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n` +
        `*Let's get started!* ðŸš€\n\n` +
        `Please send me your **Ethereum wallet address**.\n\n` +
        `ðŸ’¡ *What's a wallet address?*\n` +
        `It's like your crypto bank account number. It starts with "0x" and looks like:\n` +
        `\`0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\`\n\n` +
        `*Where to find it:*\n` +
        `â€¢ MetaMask app: Tap your address at the top\n` +
        `â€¢ Trust Wallet: Tap "Receive" â†’ Copy address\n` +
        `â€¢ Any EVM wallet: Look for "Receive" or "Address"\n\n` +
        `Just copy and paste it here! ðŸ‘‡`,
      parse_mode: 'Markdown'
    };

    await sendMessage(env.BOT_TOKEN, introMessage);

    // Store pending registration state
    await env.DB.prepare(
      `INSERT OR REPLACE INTO RegistrationSessions (UserID, TelegramChatID, Username, State, CreatedAt)
       VALUES (?, ?, ?, 'awaiting_wallet', datetime('now'))`
    ).bind(userId, chatId, username || '').run();

    return new Response(JSON.stringify({
      success: true,
      registered: false,
      awaiting: 'wallet'
    }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Error in handleStart:', error);
    throw error;
  }
}

/**
 * Handle wallet address verification and user registration
 */
async function handleWalletVerification(chatId, userId, username, walletAddress, env) {
  try {
    // Validate wallet address format
    const validation = validateEthereumAddress(walletAddress);

    if (!validation.valid) {
      const errorMessage = {
        chat_id: chatId,
        text: `âš ï¸ *Hmm, that doesn't look right...*\n\n` +
          `${validation.error}\n\n` +
          `*What I need:*\n` +
          `â€¢ Must start with "0x"\n` +
          `â€¢ Must be exactly 42 characters\n` +
          `â€¢ Contains only numbers and letters (A-F)\n\n` +
          `*Example:*\n` +
          `\`0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb\`\n\n` +
          `ðŸ’¡ *Quick tip:* Just copy it from your wallet app and paste it here.\n\n` +
          `Try again! ðŸ‘‡`,
        parse_mode: 'Markdown'
      };

      await sendMessage(env.BOT_TOKEN, errorMessage);

      return new Response(JSON.stringify({
        success: false,
        error: validation.error
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Normalize address to checksum format
    const normalizedAddress = walletAddress.toLowerCase();

    // Check if wallet is already registered
    const existingWallet = await env.DB.prepare(
      'SELECT UserID, Username FROM Users WHERE LOWER(UserWallet) = ?'
    ).bind(normalizedAddress).first();

    if (existingWallet) {
      const errorMessage = {
        chat_id: chatId,
        text: `ðŸ”’ *This wallet is already registered!*\n\n` +
          `Someone has already linked this wallet to LazaiTrader.\n\n` +
          `*What this means:*\n` +
          `â€¢ Each wallet can only have one account\n` +
          `â€¢ This keeps your funds secure\n` +
          `â€¢ Prevents duplicate trading strategies\n\n` +
          `*Your options:*\n` +
          `âœ… Use a different wallet address\n` +
          `âœ… Contact support if this is your wallet: @lazaitrader_support\n\n` +
          `Send a different wallet address to continue! ðŸ‘‡`,
        parse_mode: 'Markdown'
      };

      await sendMessage(env.BOT_TOKEN, errorMessage);

      return new Response(JSON.stringify({
        success: false,
        error: 'Wallet already registered'
      }), {
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Send processing message
    const processingMessage = {
      chat_id: chatId,
      text: `â³ *Setting up your account...*\n\n` +
        `ðŸ”§ Creating your secure trading system\n` +
        `âš¡ This takes about 10-30 seconds\n\n` +
        `*What we're doing:*\n` +
        `â€¢ Verifying your wallet address\n` +
        `â€¢ Setting up your profile\n` +
        `â€¢ Preparing your trading dashboard\n\n` +
        `Please wait... âœ¨`,
      parse_mode: 'Markdown'
    };

    await sendMessage(env.BOT_TOKEN, processingMessage);

    // Register user in database
    const now = new Date().toISOString();
    await env.DB.prepare(
      `INSERT INTO Users (UserID, UserWallet, TelegramChatID, Username, RegisteredAt, IsActive, CreatedAt)
       VALUES (?, ?, ?, ?, ?, 1, ?)`
    ).bind(userId, walletAddress, chatId, username || '', now, now).run();

    // Clear registration session
    await env.DB.prepare(
      'DELETE FROM RegistrationSessions WHERE UserID = ?'
    ).bind(userId).run();

    // Send success message
    const successMessage = {
      chat_id: chatId,
      text: `ðŸŽ‰ *You're all set!*\n\n` +
        `Your LazaiTrader account is ready!\n\n` +
        `ðŸ“‹ *Your Details:*\n` +
        `ðŸ’¼ Wallet: \`${walletAddress}\`\n` +
        `ðŸ‘¤ Telegram: @${username || 'N/A'}\n\n` +
        `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n` +
        `ðŸš€ *Next Steps:*\n\n` +
        `*1ï¸âƒ£ Set Your Strategy* âš™ï¸\n` +
        `Use /config to tell me how you want to trade:\n` +
        `â€¢ Choose trading pairs (e.g., ETH-USDC)\n` +
        `â€¢ Set your risk level\n` +
        `â€¢ Define buy/sell triggers\n\n` +
        `*2ï¸âƒ£ Fund Your Trading Wallet* ðŸ’°\n` +
        `We'll create a Smart Contract Wallet for you\n` +
        `Only you can withdraw from it!\n\n` +
        `*3ï¸âƒ£ Start Trading* ðŸ“ˆ\n` +
        `Once funded, I'll trade automatically 24/7\n` +
        `Check progress anytime with /balance or /chart\n\n` +
        `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n` +
        `*Quick Commands:*\n` +
        `/config - Set up your first strategy\n` +
        `/balance - Check your funds\n` +
        `/help - See all commands\n\n` +
        `Let's make some profits! ðŸ’Ž`,
      parse_mode: 'Markdown'
    };

    await sendMessage(env.BOT_TOKEN, successMessage);

    return new Response(JSON.stringify({
      success: true,
      registered: true,
      userId: userId,
      walletAddress: walletAddress
    }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Error in handleWalletVerification:', error);

    // Send error message to user
    const errorMessage = {
      chat_id: chatId,
      text: `âŒ *Oops! Something went wrong*\n\n` +
        `We couldn't complete your registration right now.\n\n` +
        `*Error:* ${error.message}\n\n` +
        `*What to do:*\n` +
        `â€¢ Wait a moment and try /start again\n` +
        `â€¢ Contact support if this keeps happening\n\n` +
        `Sorry for the inconvenience! ðŸ™`,
      parse_mode: 'Markdown'
    };

    await sendMessage(env.BOT_TOKEN, errorMessage);

    throw error;
  }
}

/**
 * Validate Ethereum address format
 */
function validateEthereumAddress(address) {
  if (!address || typeof address !== 'string') {
    return { valid: false, error: 'Please provide a wallet address' };
  }

  const trimmed = address.trim();

  // Check if starts with 0x
  if (!trimmed.startsWith('0x')) {
    return { valid: false, error: 'Wallet address must start with "0x"' };
  }

  // Check length (0x + 40 hex chars = 42)
  if (trimmed.length !== 42) {
    return {
      valid: false,
      error: `Wallet address must be 42 characters (yours is ${trimmed.length})`
    };
  }

  // Check if contains only valid hex characters
  const hexPart = trimmed.slice(2);
  if (!/^[0-9a-fA-F]+$/.test(hexPart)) {
    return {
      valid: false,
      error: 'Wallet address contains invalid characters (only 0-9 and A-F allowed)'
    };
  }

  return { valid: true };
}

/**
 * Send message to Telegram
 */
async function sendMessage(botToken, messageData) {
  const url = `${TELEGRAM_API}${botToken}/sendMessage`;

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(messageData)
  });

  const result = await response.json();

  if (!result.ok) {
    console.error('Telegram API error:', result);
    throw new Error(`Telegram API error: ${result.description}`);
  }

  return result;
}

// filepath: lt_tg_start\wrangler.toml
name = "lt-tg-start"
main = "worker.js"
compatibility_date = "2024-01-01"

# This worker is ONLY accessible via Service Binding from lt_tg
# No public routes - internal microservice only
workers_dev = false

# D1 Database Binding
[[d1_databases]]
binding = "DB"
database_name = "lazaitrader"
database_id = "64791295-2134-4306-a6e9-4a45619aab05"

# Environment variables
# Set BOT_TOKEN as a secret using: wrangler secret put BOT_TOKEN

